/**
 * useGitHubExport (V2)
 * GitHubã¸ã®ã‚³ãƒ¼ãƒ‰ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã‚’ç®¡ç†ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
 * å¤šè¨€èªãƒ»ãƒ—ãƒªã‚»ãƒƒãƒˆå¯¾å¿œ
 */
import { useState, useCallback, useMemo } from 'react';
import { createRepository, addFileToRepo, updateFileInRepo } from '@/services/integrations/GitHubService';
import { getSubjectFinalProject, getSubjectFinalCode, getSubjectPresets, getSubjectProjectByPreset } from '@/utils/storage/codeStorage';
import { getPresetById } from '@/config/languageConfig';
import { isGitHubConnected, getGitHubUser, type GitHubUser } from '@/utils/storage/githubStorage';

interface ExportConfig {
  repoName: string;
  description: string;
  isPrivate: boolean;
  presetId?: string; // è¿½åŠ : ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ—ãƒªã‚»ãƒƒãƒˆ
}

interface ExportResult {
  url: string;
}

interface AvailablePreset {
  presetId: string;
  label: string;
  icon: string;
  updatedAt: string;
}

interface UseGitHubExportReturn {
  githubUser: GitHubUser | null;
  isConnected: boolean;
  hasCode: boolean;
  availablePresets: AvailablePreset[]; // è¿½åŠ 
  loading: boolean;
  error: string | null;
  success: ExportResult | null;
  exportToGitHub: (config: ExportConfig) => Promise<void>;
  resetState: () => void;
}

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«å¿œã˜ãŸREADMEã‚’ç”Ÿæˆ
 */
const generateReadme = (
  subjectTitle: string,
  presetId: string,
  fileNames: string[]
): string => {
  const preset = getPresetById(presetId);
  const presetLabel = preset?.label || 'WebåŸºç¤';
  const presetIcon = preset?.icon || 'ğŸŒ';

  // ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ
  const fileList = fileNames.map(name => `â”œâ”€â”€ ${name}`).join('\n');

  // ä½¿ã„æ–¹ã®èª¬æ˜ï¼ˆãƒ—ãƒªã‚»ãƒƒãƒˆã«å¿œã˜ã¦å¤‰æ›´ï¼‰
  let usageInstructions = '';
  switch (presetId) {
    case 'web-basics':
      usageInstructions = '`index.html` ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ã€‚';
      break;
    case 'typescript-basics':
      usageInstructions = `\`\`\`bash
npx ts-node main.ts
# ã¾ãŸã¯
npx tsc main.ts && node main.js
\`\`\``;
      break;
    case 'react':
      usageInstructions = `\`\`\`bash
npm create vite@latest my-app -- --template react-ts
# ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã‹ã‚‰
npm install
npm run dev
\`\`\``;
      break;
    case 'vue':
      usageInstructions = `\`\`\`bash
npm create vue@latest
# ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã‹ã‚‰
npm install
npm run dev
\`\`\``;
      break;
    case 'python':
      usageInstructions = `\`\`\`bash
python main.py
\`\`\``;
      break;
    default:
      usageInstructions = 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å®Ÿè¡Œç’°å¢ƒã«åˆã‚ã›ã¦ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚';
  }

  return `# ${subjectTitle}

${presetIcon} **${presetLabel}** ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ [Pathly](https://frontend-prod-xi.vercel.app) ã§å­¦ç¿’ã—ãŸå†…å®¹ã§ã™ã€‚

## ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ

\`\`\`
${fileList}
â””â”€â”€ README.md
\`\`\`

## ğŸš€ ä½¿ã„æ–¹

${usageInstructions}

## ğŸ“… ä½œæˆæ—¥

${new Date().toLocaleDateString('ja-JP')}

---

*Generated by Pathly - ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°å­¦ç¿’ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ *
`;
};

export const useGitHubExport = (
  subjectId: number,
  subjectTitle: string
): UseGitHubExportReturn => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<ExportResult | null>(null);

  const githubUser = getGitHubUser();
  const isConnected = isGitHubConnected();
  
  // åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆä¸€è¦§ã‚’å–å¾—
  const availablePresets = useMemo<AvailablePreset[]>(() => {
    const presets = getSubjectPresets(subjectId);
    return presets.map(p => {
      const presetDef = getPresetById(p.presetId);
      return {
        presetId: p.presetId,
        label: presetDef?.label || p.presetId,
        icon: presetDef?.icon || 'ğŸ“„',
        updatedAt: p.updatedAt,
      };
    }).sort((a, b) => b.updatedAt.localeCompare(a.updatedAt));
  }, [subjectId]);

  // æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°æ—§å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  const finalProject = getSubjectFinalProject(subjectId);
  const finalCode = getSubjectFinalCode(subjectId);
  const hasCode = finalProject !== null || finalCode !== null || availablePresets.length > 0;

  const resetState = useCallback(() => {
    setLoading(false);
    setError(null);
    setSuccess(null);
  }, []);

  const exportToGitHub = useCallback(
    async (config: ExportConfig) => {
      if (!isConnected || !githubUser) {
        setError('GitHubã¨é€£æºã—ã¦ãã ã•ã„');
        return;
      }

      if (!hasCode) {
        setError('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚');
        return;
      }

      setLoading(true);
      setError(null);

      try {
        // ãƒªãƒã‚¸ãƒˆãƒªã‚’ä½œæˆ
        const repo = await createRepository({
          name: config.repoName,
          description: config.description,
          isPrivate: config.isPrivate,
        });

        // GitHub APIã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–
        await delay(1500);

        // ãƒ—ãƒªã‚»ãƒƒãƒˆãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ãã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—
        let projectToExport = config.presetId 
          ? getSubjectProjectByPreset(subjectId, config.presetId)
          : null;
        let presetId = config.presetId || 'web-basics';

        // ãƒ—ãƒªã‚»ãƒƒãƒˆæŒ‡å®šãŒãªã‘ã‚Œã°æœ€æ–°ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨
        if (!projectToExport && finalProject) {
          projectToExport = { files: finalProject.files };
          presetId = finalProject.presetId;
        }

        // æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ã‚’ä½¿ç”¨
        if (projectToExport) {
          const fileNames = Object.keys(projectToExport.files);

          // READMEã‚’æ›´æ–°
          const readmeContent = generateReadme(subjectTitle, presetId, fileNames);
          await updateFileInRepo(githubUser.login, config.repoName, {
            path: 'README.md',
            content: readmeContent,
          });

          // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ 
          for (const [filename, fileData] of Object.entries(projectToExport.files)) {
            if (fileData.content) {
              await addFileToRepo(githubUser.login, config.repoName, {
                path: filename,
                content: fileData.content,
              });
            }
          }
        } else if (finalCode) {
          // æ—§å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          const readmeContent = generateReadme(subjectTitle, 'web-basics', ['index.html', 'style.css', 'script.js']);
          await updateFileInRepo(githubUser.login, config.repoName, {
            path: 'README.md',
            content: readmeContent,
          });

          if (finalCode.html) {
            await addFileToRepo(githubUser.login, config.repoName, {
              path: 'index.html',
              content: finalCode.html,
            });
          }
          if (finalCode.css) {
            await addFileToRepo(githubUser.login, config.repoName, {
              path: 'style.css',
              content: finalCode.css,
            });
          }
          if (finalCode.js) {
            await addFileToRepo(githubUser.login, config.repoName, {
              path: 'script.js',
              content: finalCode.js,
            });
          }
        }

        setSuccess({ url: repo.html_url });
      } catch (err) {
        console.error('Export error:', err);
        setError(err instanceof Error ? err.message : 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      } finally {
        setLoading(false);
      }
    },
    [isConnected, githubUser, finalProject, finalCode, hasCode, subjectTitle]
  );

  return {
    githubUser,
    isConnected,
    hasCode,
    availablePresets,
    loading,
    error,
    success,
    exportToGitHub,
    resetState,
  };
};

/**
 * ãƒªãƒã‚¸ãƒˆãƒªåã‚’æ—¥ä»˜ãƒ™ãƒ¼ã‚¹ã§ç”Ÿæˆ
 */
export const generateRepoName = (): string => {
  const now = new Date();
  const date = now.toISOString().slice(0, 10).replace(/-/g, '');
  return `pathly-project-${date}`;
};